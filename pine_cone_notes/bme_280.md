# read temperatures and humidity from BME 280

BME 280 is a combined digital humidity, pressure and temperature sensor from Bosch Sensortec.
It provides I2C or SPI interface for connection. The data sheet is available at
[BME280](https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme280-ds002.pdf)
. There are quite a few choices when buying from the market. I purchased one from
[Amazon](https://www.amazon.com/BME280/s?k=BME280), and another one from
[Sparkfun](https://www.sparkfun.com/sparkfun-atmospheric-sensor-breakout-bme280.html).
I will decribe the difference between them later on.

Connecting BME 280 to the BL602 based pine cone and making it work requires to understand
several things: (1) Which interface is used for the communication between them? (2) Which pins of
BL602 connects to the pins of BME 280? (3) How BME 280 gets programmed to read
humidity/pressure/temperature?

## Which interface is used for ocmmunication between BL602 and the BME 280?

The BME 280 module purchased from Amazon has four pins marked as **VIN, GND, SCL, and SDA**.
Though this product is marketed as I2C/SPI compatible, I assume it supports I2C officially.
(The sale page said it is 5V sensor module, the experiment seems to indicate 3.3v works OK too.)

![alt text](gybmep.jpeg "GY-BME280")

The BME 280 module from Sparkfun has two sets of pins. One set consists of **GND, 3.3V, SDA,
and SCL**, and the second set pins consists of **\_CS, SDI, SDO, SCK, 3.3v, and GND**. This
module clearly supports both SPI and I2C.

![alt text](sparkfun_bme280.jpg "sparkfun-bme280")

Thus, I would choose I2C interface for the sake of both BME 280 modules.

## Which pines of BL602 connects to the pines of BME280?

[BL602/BL604 reference
manual](https://github.com/pine64/bl602-docs/blob/b214ef8e4fdef06de528dd6fc5d8e7da24c19159/mirrored/Bouffalo%20Lab%20BL602_Reference_Manual_en_1.1.pdf)
page 27/209 shows that there are 23 pins. The BL602 board of Pine64 reference design has 18
pins. These pins can be configured into different GPIO functions, including I2C. Take the
example of I2C, GPIO_0/GPIO_1, GPIO_2/GPIO_3, GPIO_4/GPIO_5,....,GPIO_20/GPIO_21 can be
configured to SCL/SDA for I2C port.

Technically you can see many pairs of pins can be used for I2C simutaniously. Yet, this is not
necessary true. The reference code of BL602 configures the GPIO pin 3 and GPIO 4 for I2C,
nothing else.
```c
 /* hal_drv/bl602_hal/bl_i2c.c */
 57 void i2c_gpio_init(int i2cx)
 58 {
 59     uint8_t gpiopins[2];
 60     if (i2cx == I2C0) {
 61         gpiopins[0] = GLB_GPIO_PIN_4;
 62         gpiopins[1] = GLB_GPIO_PIN_3;
 63     } else {
 64     }
 65
 66     GLB_GPIO_Func_Init(GPIO_FUN_I2C, gpiopins, sizeof(gpiopins) / sizeof(gpiopins[0]));
 67     return;
 68 }
```

This is not the worst. If I2C registers are provided for all I2C ports, it is possible to add
additional support of other I2C ports. But this piece is missing in the reference code, and
related reference manual. I may poke around this in future.

Based on this, we would use GPIO pin 3 and 4 to connect BME 280. Here is the connection.
**TODO: Add the picture of connection here.**

## How BME 280 gets programmed to read humidity/pressure/temperature?

Knowing to use I2C is not enough. In order to know how to milk the BME 280 and drive it work,
we have to read the [data
sheet](https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme280-ds002.pdf).

The BME 280 register maps are shown below:
![alt text](bme280_register.png "bme280 registers")

Apparently read-only registers are not configurable. They exist for retrieving. Among them are
humidity registers, temperature registers, pressure registers, calibration register, and id
register. Other than reset register (0xE0), this leaves three registers only: config register
(0xF5), ctrl_meas register (0xF4), and ctrl_hum register (0xF2).

- register **ctrl_hum** (0xF2)

| [7:3]  |  [2:0] |
| ------ | ------ |
| unused | osrs_h[2:0] |

The field *osrs_h* is oversampling register settings for humidity (osrs_h).

| osrs_h[2:0] | humidity oversampling |
| ----------- | ------------- |
| 000          | skipped (output set to 0x8000)  |
| 001          | oversampling x1  |
| 010          | oversampling x2  |
| 011          | oversampling x4  |
| 100          | oversampling x8  |
| 101, others  | oversampling x16 |

This instructs how many samples of humidity the sensor collects for single reading session.
The samples are filtered if necessary when configured so.

- register **ctrl_meas** (0xF4)

|    [7:5]    |    [4:2]    |   [1:0]   |
| ----------- | ----------- | --------- |
| osrs_t[2:0] | osrs_p[2:0] | mode[1:0] |

The fields *osrs_t* and *osrs_p* are the same as the field of *osrs_h* described above. The
field *mode* is the setting on how the sensor operates. It supports the following:

| mode[1:0]  |     mode    |
| ---------- | ----------- |
|   00       |  sleep mode |
|   01/10    |  forced mode|
|   11       | normal mode |

- register **config** (0xF5)

|      [7:5]      |  [4:2] | [1:1] |       [0:0]       |
| ------------    | ------ |-------|-------------------|
| time of standby | filter |  -    | enable 3-wire spi |

The time of standby settings is defined as below:

|   t_sb[2:0]  |  time of standby [ms] |
| -----------  | ------------------- |
| 000          |        0.5          |
| 001          |        62.5         |
| 010          |        125          |
| 011          |        250          |
| 100          |        500          |
| 101          |        1000         |
| 110          |        10           |
| 111          |        20           |

, and the filter settings is as follows:

| filter[2:0] | filter coefficient |
| ----------- | ------------- |
| 000          | filter off  |
| 001          | 2  |
| 010          | 4  |
| 011          | 8  |
| 100, others  | 16 |

These registers are the ones that we are going to program. For the simplicity,
I will use forced-mode, oversampling being set to 1, and read the data from the registers
from 0xF7 to 0xFE. In summary, the tables show the values to be programmed:

| ctrl_hum (0xF2) |  ctrl_meas (0xF4) | config (0xF5) |
| --------------- | ----------------- | ------------- |
|    0x1          |     0x25          |     -         |

The data read from the registers are raw, which means it needs to process further to
get human-friendly information. The data sheet provides the compensation formular to do the
conversion, with the data in calibration registers (0x88 ~ 0xA1, and 0xE1 ~ 0xF0). Please
refer to the above mentioned BME 280 data sheet for the formular.

## I2C in BL 602

## The code

## The difference between the two BME 280 sensor modules
